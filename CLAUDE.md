<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->
<!-- Migration Version: 1.2.0 -->

# Project Instructions for Claude

## Project Guidelines

---
applyTo: '**/*.tsx'
description: Prompt-TSX coding guidelines
---

Guidelines for TSX files using [prompt-tsx](https://github.com/microsoft/vscode-prompt-tsx) focusing on specific patterns and token budget management for AI prompt engineering.

## Component Structure

### Base Pattern
- Extend `PromptElement<Props>` or `PromptElement<Props, State>` for all prompt components
- Props interfaces must extend `BasePromptElementProps`

```tsx
interface MyPromptProps extends BasePromptElementProps {
	readonly userQuery: string;
}

class MyPrompt extends PromptElement<MyPromptProps> {
	render() {
		return (
			<>
				<SystemMessage priority={1000}>...</SystemMessage>
				<UserMessage priority={900}>{this.props.userQuery}</UserMessage>
			</>
		);
	}
}
```

### Async Components
- The `render` method can be async for components that need to perform async operations
- All async work should be done directly in the `render` method

```tsx
class FileContextPrompt extends PromptElement<FileContextProps> {
	async render() {
		const fileContent = await readFileAsync(this.props.filePath);
		return (
			<>
				<SystemMessage priority={1000}>File content:</SystemMessage>
				<UserMessage priority={900}>{fileContent}</UserMessage>
			</>
		);
	}
}
```

## Prompt-Specific JSX

### Line Breaks
- **CRITICAL**: Use `<br />` for line breaks - newlines are NOT preserved in JSX
- Never rely on whitespace or string literal newlines

```tsx
// ✅ Correct
<SystemMessage>
	You are an AI assistant.<br />
	Follow these guidelines.<br />
</SystemMessage>

// ❌ Wrong - newlines will be collapsed
<SystemMessage>
	You are an AI assistant.
	Follow these guidelines.
</SystemMessage>
```

## Priority System

### Priority Values
- Higher numbers = higher priority (like z-index)
- Use consistent ranges:
  - System messages: 1000
  - User queries: 900
  - Recent history: 700-800
  - Context/attachments: 600-700
  - Background info: 0-500

```tsx
<SystemMessage priority={1000}>...</SystemMessage>
<UserMessage priority={900}>{query}</UserMessage>
<HistoryMessages priority={700} />
<ContextualData priority={500} />
```

### Flex Properties for Token Budget
- `flexGrow={1}` - expand to fill remaining token space
- `flexReserve` - reserve tokens before rendering
- `passPriority` - pass-through containers that don't affect child priorities

```tsx
<FileContext priority={70} flexGrow={1} files={this.props.files} />
<History passPriority older={0} newer={80} flexGrow={2} flexReserve="/5" />
```

## Content Handling

### TextChunk for Truncation
- Use `TextChunk` for content that may exceed token budget
- Set `breakOn` patterns for intelligent truncation

```tsx
<TextChunk breakOnWhitespace priority={100}>
	{longUserQuery}
</TextChunk>

<TextChunk breakOn=" " priority={80}>
	{documentContent}
</TextChunk>
```

### Tag Component for Structured Content
- Use `Tag` for XML-like structured content with attributes
- Validates tag names and properly formats attributes

```tsx
<Tag name="attachments" attrs={{ id: variableName, type: "file" }}>
	{content}
</Tag>
```

## References and Metadata

### Prompt References
- Use `<references>` for tracking variable usage
- Use `<meta>` for metadata that survives pruning

```tsx
<references value={[new PromptReference({ variableName })]} />
<meta value={new ToolResultMetadata(id, result)} />
```

### Keep-With Pattern
- Use `useKeepWith()` for content that should be pruned together

```tsx
const KeepWith = useKeepWith();
return (
	<>
		<KeepWith priority={2}>
			<ToolCallRequest>...</ToolCallRequest>
		</KeepWith>
		<KeepWith priority={1}>
			<ToolCallResponse>...</ToolCallResponse>
		</KeepWith>
	</>
);
```

## Token Budget Management

### Sizing-Aware Rendering
- Use `PromptSizing` parameter for budget-aware content generation
- Implement cooperative token usage

```tsx
async render(sizing: PromptSizing): Promise<PromptPiece> {
	const content = await this.generateContent(sizing.tokenBudget);
	return <>{content}</>;
}
```

### Performance
- Avoid expensive work in `render` methods when possible
- Cache computations when appropriate
- Use async `render` for all async operations

---
applyTo: '**/*.spec.ts'
description: Vitest unit testing guidelines
---

Please follow these guidelines when writing unit tests using Vitest. These tests are `*.spec.ts`

## Best Practices

- Prefer explicit Test/Mock classes over mutating real instances or creating adhoc one-off mocks.
    - Never use `as any` to override private methods or assign properties on real objects.
    - Mock versions of services are typically named `Mock*` or `Test*`, you can search to find whether one already exists.
    - Some examples: `MockFileSystemService`, `MockChatResponseStream`, `TestTasksService`.

- If there is no preexisting implementation of a service that is appropriate to reuse in the test, then you can create a simple mock or stub implementation in a file under a `test/` folder near the interface definition.
    - A mock class should be configurable so that it can be shared and set up for different test scenarios.

- The helper `createExtensionUnitTestingServices` returns a `TestingServiceCollection` preconfigured with some common mock services, use `IInstantiationService` to create instances with those mocks. Here's an example of using it properly

```ts
const serviceCollection = store.add(createExtensionUnitTestingServices());
instantiationService = serviceCollection.createTestingAccessor().get(IInstantiationService);
const mockFs = accessor.get(IFileSystemService) as MockFileSystemService;
const testService = instantiationService.createInstance(SomeServiceToTest);
```

- When asked to write new tests, add tests to cover the behavior of the code under test, especially things that are interesting, unexpected, or edge cases.
    - Avoid adding tests that simply repeat existing tests or cover trivial code paths.

- If available, prefer the runTests tool to run tests over a terminal command.

- Keep tests deterministic and fast.
    - Avoid starting real servers or performing network I/O.

- Avoid excessive repetition in tests, use `beforeEach` to set up common state.
    - Use helper functions to encapsulate common test logic.

## Available Commands

### Built-in Agents

| Command | Description |
|---------|-------------|
| `/agent` | General-purpose coding agent for implementing features, fixing bugs, and writing code |
| `/architect` | Designs technical implementation plans with file-level specificity. Writes plan to file and requests user approval before completing. |
| `/reviewer` | Reviews code changes for quality, correctness, and best practices |
| `/repository-researcher` | Investigates codebase architecture, patterns, and best practices with access to architecture documents |
| `/orchestrator` | Orchestrate multi-agent workflows, deploy plans, manage workers, and coordinate parallel execution |
| `/product` | Provides product and UX expertise for user-facing decisions |
| `/researcher` | Investigates codebases using symbolic navigation to understand how things work |
| `/tester` | Designs test strategies and writes comprehensive tests |

---

*This file was auto-generated from `.github/agents/` and `.github/instructions/`.*
*Run `Copilot: Regenerate Claude Configuration` to update.*
