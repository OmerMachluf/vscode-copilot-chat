/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { FileType } from 'vscode';
import * as vscode from 'vscode';
import { ClaudeMigrationService, MigrationStatus } from '../claudeMigrationService';
import { URI } from '../../../util/vs/base/common/uri';

// Mock vscode
vi.mock('vscode', () => ({
	workspace: {
		workspaceFolders: [],
	},
	Uri: {
		file: (path: string) => URI.file(path),
		joinPath: (base: any, ...paths: string[]) => URI.joinPath(base, ...paths),
	},
	FileType: {
		File: 1,
		Directory: 2,
	},
}));

// Mock file system service
class MockFileSystemService {
	private files: Map<string, Uint8Array> = new Map();
	private directories: Set<string> = new Set();

	async stat(uri: URI): Promise<{ type: number }> {
		const path = uri.toString();
		if (this.files.has(path)) {
			return { type: 1 }; // FileType.File
		}
		if (this.directories.has(path)) {
			return { type: 2 }; // FileType.Directory
		}
		throw new Error(`File not found: ${path}`);
	}

	async readFile(uri: URI): Promise<Uint8Array> {
		const path = uri.toString();
		const content = this.files.get(path);
		if (!content) {
			throw new Error(`File not found: ${path}`);
		}
		return content;
	}

	async writeFile(uri: URI, content: Uint8Array): Promise<void> {
		this.files.set(uri.toString(), content);
	}

	async createDirectory(uri: URI): Promise<void> {
		this.directories.add(uri.toString());
	}

	async readDirectory(uri: URI): Promise<[string, FileType][]> {
		const prefix = uri.toString();
		const results: [string, FileType][] = [];
		
		for (const path of this.files.keys()) {
			if (path.startsWith(prefix)) {
				const relativePath = path.substring(prefix.length + 1);
				if (!relativePath.includes('/')) {
					results.push([relativePath, FileType.File]);
				}
			}
		}
		
		return results;
	}

	// Test helpers
	setFile(uri: URI, content: string): void {
		this.files.set(uri.toString(), new TextEncoder().encode(content));
	}

	getFile(uri: URI): string | undefined {
		const content = this.files.get(uri.toString());
		return content ? new TextDecoder().decode(content) : undefined;
	}

	clear(): void {
		this.files.clear();
		this.directories.clear();
	}
}

// Mock log service
class MockLogService {
	info = vi.fn();
	warn = vi.fn();
	error = vi.fn();
	debug = vi.fn();
	trace = vi.fn();
}

describe('ClaudeMigrationService', () => {
	let service: ClaudeMigrationService;
	let mockFs: MockFileSystemService;
	let mockLog: MockLogService;

	beforeEach(() => {
		mockFs = new MockFileSystemService();
		mockLog = new MockLogService();

		// Set up workspace folders mock
		(vscode.workspace as any).workspaceFolders = [{ uri: URI.file('/test/workspace') }];

		// Create service with just 2 args (IFileSystemService, ILogService)
		service = new ClaudeMigrationService(
			mockFs as any,
			mockLog as any
		);
	});

	describe('shouldMigrate', () => {
		it('should return true when CLAUDE.md does not exist', async () => {
			const result = await service.shouldMigrate();
			expect(result).toBe(true);
		});

		it('should return false when workspace has no folders', async () => {
			(vscode.workspace as any).workspaceFolders = undefined;
			const result = await service.shouldMigrate();
			expect(result).toBe(false);
		});

		it('should return false when CLAUDE.md exists but was not auto-generated', async () => {
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			mockFs.setFile(claudeMdPath, '# My Custom Claude Config\n\nManually created.');
			
			const result = await service.shouldMigrate();
			expect(result).toBe(false);
		});

		it('should return true when CLAUDE.md is auto-generated but outdated', async () => {
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			mockFs.setFile(claudeMdPath, 
				'<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->\n' +
				'<!-- Migration Version: 0.9.0 -->\n' +
				'# Claude Config'
			);
			
			const result = await service.shouldMigrate();
			expect(result).toBe(true);
		});

		it('should return false when CLAUDE.md is auto-generated and current version', async () => {
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			mockFs.setFile(claudeMdPath, 
				'<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->\n' +
				'<!-- Migration Version: 1.0.0 -->\n' +
				'# Claude Config'
			);
			
			const result = await service.shouldMigrate();
			expect(result).toBe(false);
		});
	});

	describe('getMigrationStatus', () => {
		it('should return Pending initially', () => {
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Pending);
		});
	});

	describe('migrate', () => {
		it('should return NotNeeded when no workspace folders', async () => {
			(vscode.workspace as any).workspaceFolders = undefined;
			
			const result = await service.migrate();
			
			expect(result.status).toBe(MigrationStatus.NotNeeded);
			expect(result.generatedFiles).toHaveLength(0);
		});

		it('should generate CLAUDE.md with built-in agents', async () => {
			const result = await service.migrate();
			
			expect(result.status).toBe(MigrationStatus.Completed);
			expect(result.generatedFiles).toHaveLength(2);
			
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);
			
			expect(content).toContain('<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->');
			expect(content).toContain('# Claude Code Configuration');
			expect(content).toContain('/agent');
			expect(content).toContain('/architect');
			expect(content).toContain('/reviewer');
			expect(content).toContain('/repository-researcher');
		});

		it('should generate SLASH_COMMANDS.md', async () => {
			const result = await service.migrate();
			
			expect(result.status).toBe(MigrationStatus.Completed);
			
			const slashCommandsPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'SLASH_COMMANDS.md'
			);
			const content = mockFs.getFile(slashCommandsPath);
			
			expect(content).toContain('# Slash Commands Reference');
			expect(content).toContain('| Command | Description | Type |');
			expect(content).toContain('`/agent`');
		});

		it('should set status to Completed on success', async () => {
			await service.migrate();
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Completed);
		});

		it('should be idempotent when called multiple times', async () => {
			const result1 = await service.migrate();
			const result2 = await service.migrate();
			
			// Second call should still work (status is Completed, not InProgress)
			expect(result1.status).toBe(MigrationStatus.Completed);
			expect(result2.status).toBe(MigrationStatus.Completed);
		});

		it('should include custom agents when present', async () => {
			// Create a custom agent file
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'MyCustomAgent.agent.md'
			);
			mockFs.setFile(agentPath, 
				'---\n' +
				'name: my-custom-agent\n' +
				'description: A custom agent for testing\n' +
				'---\n' +
				'\n' +
				'This is a custom agent that does custom things.'
			);
			
			// Mark the directory as existing
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const result = await service.migrate();
			
			expect(result.status).toBe(MigrationStatus.Completed);
			
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);
			
			expect(content).toContain('Custom Agents');
			expect(content).toContain('/my-custom-agent');
		});
	});

	describe('regenerate', () => {
		it('should regenerate files even after successful migration', async () => {
			// First migration
			await service.migrate();
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Completed);
			
			// Regenerate
			const result = await service.regenerate();
			
			expect(result.status).toBe(MigrationStatus.Completed);
			expect(result.generatedFiles).toHaveLength(2);
		});

		it('should clear cached agent definitions', async () => {
			// Get definitions to cache them
			const agents1 = await service.getAgentDefinitions();
			
			// Regenerate should clear cache
			await service.regenerate();
			
			const agents2 = await service.getAgentDefinitions();
			
			// Both should have the same built-in agents
			expect(agents1.length).toBe(agents2.length);
		});
	});

	describe('getAgentDefinitions', () => {
		it('should return built-in agents', async () => {
			const agents = await service.getAgentDefinitions();
			
			expect(agents.length).toBeGreaterThanOrEqual(4);
			
			const agentNames = agents.map(a => a.name);
			expect(agentNames).toContain('agent');
			expect(agentNames).toContain('architect');
			expect(agentNames).toContain('reviewer');
			expect(agentNames).toContain('repository-researcher');
		});

		it('should mark built-in agents correctly', async () => {
			const agents = await service.getAgentDefinitions();
			
			const builtInAgents = agents.filter(a => a.isBuiltIn);
			expect(builtInAgents.length).toBe(4);
		});

		it('should cache agent definitions', async () => {
			const agents1 = await service.getAgentDefinitions();
			const agents2 = await service.getAgentDefinitions();
			
			// Same reference means cached
			expect(agents1).toBe(agents2);
		});
	});

	describe('agent file parsing', () => {
		it('should parse agent file with frontmatter', async () => {
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'TestAgent.agent.md'
			);
			mockFs.setFile(agentPath, 
				'---\n' +
				'name: test-agent\n' +
				'description: Test agent description\n' +
				'---\n' +
				'\n' +
				'Instructions for the test agent.'
			);
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const customAgent = agents.find(a => a.name === 'test-agent');
			
			expect(customAgent).toBeDefined();
			expect(customAgent!.description).toBe('Test agent description');
			expect(customAgent!.slashCommand).toBe('/test-agent');
			expect(customAgent!.isBuiltIn).toBe(false);
		});

		it('should derive name from filename when not in frontmatter', async () => {
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'MyFancyAgent.agent.md'
			);
			mockFs.setFile(agentPath, 'Just some instructions without frontmatter.');
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const customAgent = agents.find(a => a.slashCommand === '/my-fancy-agent');
			
			expect(customAgent).toBeDefined();
			expect(customAgent!.name).toBe('my-fancy-agent');
		});

		it('should not duplicate built-in agents from custom files', async () => {
			// Create a file named like a built-in agent
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'Architect.agent.md'
			);
			mockFs.setFile(agentPath, 
				'---\n' +
				'name: architect\n' +
				'---\n' +
				'Custom architect override.'
			);
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const architectAgents = agents.filter(a => a.name === 'architect');
			
			// Should only have the built-in one
			expect(architectAgents).toHaveLength(1);
			expect(architectAgents[0].isBuiltIn).toBe(true);
		});
	});

	describe('content generation', () => {
		it('should include version marker in generated files', async () => {
			await service.migrate();
			
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);
			
			expect(content).toContain('<!-- Migration Version: 1.0.0 -->');
		});

		it('should include usage examples', async () => {
			await service.migrate();
			
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);
			
			expect(content).toContain('## Usage');
			expect(content).toContain('/architect Design a new authentication system');
		});

		it('should include regeneration instructions', async () => {
			await service.migrate();
			
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'claude',
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);
			
			expect(content).toContain('## Regeneration');
			expect(content).toContain('Copilot: Regenerate Claude Configuration');
		});
	});
});
