/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { FileType } from 'vscode';
import * as vscode from 'vscode';
import { ClaudeMigrationService, MigrationStatus } from '../claudeMigrationService';
import { URI } from '../../../util/vs/base/common/uri';

// Mock vscode
vi.mock('vscode', () => ({
	workspace: {
		workspaceFolders: [],
	},
	Uri: {
		file: (path: string) => URI.file(path),
		joinPath: (base: any, ...paths: string[]) => URI.joinPath(base, ...paths),
	},
	FileType: {
		File: 1,
		Directory: 2,
	},
}));

// Mock file system service
class MockFileSystemService {
	private files: Map<string, Uint8Array> = new Map();
	private directories: Set<string> = new Set();
	private fileMtimes: Map<string, number> = new Map();

	async stat(uri: URI): Promise<{ type: number; mtime: number }> {
		const path = uri.toString();
		if (this.files.has(path)) {
			return { type: 1, mtime: this.fileMtimes.get(path) ?? Date.now() }; // FileType.File
		}
		if (this.directories.has(path)) {
			return { type: 2, mtime: Date.now() }; // FileType.Directory
		}
		throw new Error(`File not found: ${path}`);
	}

	async readFile(uri: URI): Promise<Uint8Array> {
		const path = uri.toString();
		const content = this.files.get(path);
		if (!content) {
			throw new Error(`File not found: ${path}`);
		}
		return content;
	}

	async writeFile(uri: URI, content: Uint8Array): Promise<void> {
		this.files.set(uri.toString(), content);
	}

	async createDirectory(uri: URI): Promise<void> {
		this.directories.add(uri.toString());
	}

	async readDirectory(uri: URI): Promise<[string, FileType][]> {
		const prefix = uri.toString();
		const results: [string, FileType][] = [];
		
		for (const path of this.files.keys()) {
			if (path.startsWith(prefix)) {
				const relativePath = path.substring(prefix.length + 1);
				if (!relativePath.includes('/')) {
					results.push([relativePath, FileType.File]);
				}
			}
		}
		
		return results;
	}

	// Test helpers
	setFile(uri: URI, content: string, mtime?: number): void {
		this.files.set(uri.toString(), new TextEncoder().encode(content));
		this.fileMtimes.set(uri.toString(), mtime ?? Date.now());
	}

	getFile(uri: URI): string | undefined {
		const content = this.files.get(uri.toString());
		return content ? new TextDecoder().decode(content) : undefined;
	}

	setFileMtime(uri: URI, mtime: number): void {
		this.fileMtimes.set(uri.toString(), mtime);
	}

	clear(): void {
		this.files.clear();
		this.directories.clear();
		this.fileMtimes.clear();
	}
}

// Mock log service
class MockLogService {
	info = vi.fn();
	warn = vi.fn();
	error = vi.fn();
	debug = vi.fn();
	trace = vi.fn();
}

describe('ClaudeMigrationService', () => {
	let service: ClaudeMigrationService;
	let mockFs: MockFileSystemService;
	let mockLog: MockLogService;

	beforeEach(() => {
		mockFs = new MockFileSystemService();
		mockLog = new MockLogService();

		// Set up workspace folders mock
		(vscode.workspace as any).workspaceFolders = [{ uri: URI.file('/test/workspace') }];

		// Create service with just 2 args (IFileSystemService, ILogService)
		service = new ClaudeMigrationService(
			mockFs as any,
			mockLog as any
		);
	});

	describe('shouldMigrate', () => {
		it('should return true when CLAUDE.md does not exist', async () => {
			const result = await service.shouldMigrate();
			expect(result).toBe(true);
		});

		it('should return false when workspace has no folders', async () => {
			(vscode.workspace as any).workspaceFolders = undefined;
			const result = await service.shouldMigrate();
			expect(result).toBe(false);
		});

		it('should return true when CLAUDE.md exists but was not auto-generated', async () => {
			// CLAUDE.md is now at workspace root
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			mockFs.setFile(claudeMdPath, '# My Custom Claude Config\n\nManually created.');

			const result = await service.shouldMigrate();
			// Should return true - we always replace CLAUDE.md and command/agent files are missing
			expect(result).toBe(true);
		});

		it('should return true when CLAUDE.md is auto-generated but outdated', async () => {
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			mockFs.setFile(claudeMdPath,
				'<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->\n' +
				'<!-- Migration Version: 0.9.0 -->\n' +
				'# Claude Config'
			);

			const result = await service.shouldMigrate();
			expect(result).toBe(true);
		});

		it('should return false when CLAUDE.md is auto-generated and current version with all files present', async () => {
			const workspaceRoot = URI.file('/test/workspace');

			// Set up CLAUDE.md with current version
			const claudeMdPath = URI.joinPath(workspaceRoot, 'CLAUDE.md');
			mockFs.setFile(claudeMdPath,
				'<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->\n' +
				'<!-- Migration Version: 1.2.0 -->\n' +
				'# Claude Config'
			);

			// Set up all expected command files
			const builtinAgents = ['agent', 'architect', 'reviewer', 'repository-researcher'];
			for (const agentName of builtinAgents) {
				const commandPath = URI.joinPath(workspaceRoot, '.claude', 'commands', `${agentName}.md`);
				mockFs.setFile(commandPath, `---\nname: ${agentName}\n---\nUse @${agentName}`);
			}

			// Set up all expected agent files (except 'agent' which is skipped)
			for (const agentName of builtinAgents) {
				if (agentName === 'agent') {
					continue; // Default agent doesn't have an agent file
				}
				const agentPath = URI.joinPath(workspaceRoot, '.claude', 'agents', 'builtin', `${agentName}.md`);
				mockFs.setFile(agentPath, `---\nname: ${agentName}\n---\nYou are ${agentName}`);
			}

			const result = await service.shouldMigrate();
			expect(result).toBe(false);
		});
	});

	describe('getMigrationStatus', () => {
		it('should return Pending initially', () => {
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Pending);
		});
	});

	describe('migrate', () => {
		it('should return NotNeeded when no workspace folders', async () => {
			(vscode.workspace as any).workspaceFolders = undefined;

			const result = await service.migrate();

			expect(result.status).toBe(MigrationStatus.NotNeeded);
			expect(result.generatedFiles).toHaveLength(0);
		});

		it('should generate CLAUDE.md with built-in agents', async () => {
			const result = await service.migrate();

			expect(result.status).toBe(MigrationStatus.Completed);
			// Now generates:
			// - 3 builtin agent files (.claude/agents/builtin/*.md) - agent is skipped as it's the default
			// - 4 command files (.claude/commands/*.md) - all agents including agent get commands
			// - 1 CLAUDE.md
			// - 1 .claude/settings.json
			// Total: 9 files
			expect(result.generatedFiles).toHaveLength(9);

			// CLAUDE.md is now at workspace root
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);

			expect(content).toBeDefined();
			expect(content).toContain('<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->');
			expect(content).toContain('# Project Instructions for Claude');
			expect(content).toContain('/agent');
			expect(content).toContain('/architect');
			expect(content).toContain('/reviewer');
			expect(content).toContain('/repository-researcher');

			// Verify agent files are created in proper structure
			// Note: agent.md is NOT created because 'agent' is the default all-capable agent
			// Check architect.md instead
			const architectPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'agents', 'builtin', 'architect.md'
			);
			const architectContent = mockFs.getFile(architectPath);
			expect(architectContent).toBeDefined();
			expect(architectContent).toContain('name: architect');
			expect(architectContent).toContain('description:');

			// Verify agent command file IS created (even though agent.md is not)
			const agentCommandPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'commands', 'agent.md'
			);
			const agentCommandContent = mockFs.getFile(agentCommandPath);
			expect(agentCommandContent).toBeDefined();
			expect(agentCommandContent).toContain('Use the @agent agent');
		});

		it('should generate .claude/settings.json', async () => {
			const result = await service.migrate();

			expect(result.status).toBe(MigrationStatus.Completed);

			const settingsPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude',
				'settings.json'
			);
			const content = mockFs.getFile(settingsPath);

			expect(content).toBeDefined();
			expect(content).toContain('Auto-generated by GitHub Copilot extension');
		});

		it('should set status to Completed on success', async () => {
			await service.migrate();
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Completed);
		});

		it('should be idempotent when called multiple times', async () => {
			const result1 = await service.migrate();
			const result2 = await service.migrate();

			// Second call should still work (status is Completed, not InProgress)
			expect(result1.status).toBe(MigrationStatus.Completed);
			expect(result2.status).toBe(MigrationStatus.Completed);
		});

		it('should include custom agents when present', async () => {
			// Create a custom agent file
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'MyCustomAgent.agent.md'
			);
			mockFs.setFile(agentPath,
				'---\n' +
				'name: my-custom-agent\n' +
				'description: A custom agent for testing\n' +
				'---\n' +
				'\n' +
				'This is a custom agent that does custom things.'
			);

			// Mark the directory as existing
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);

			const result = await service.migrate();

			expect(result.status).toBe(MigrationStatus.Completed);

			// CLAUDE.md is at workspace root
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);

			expect(content).toBeDefined();
			expect(content).toContain('Custom Agents');
			expect(content).toContain('/my-custom-agent');
		});
	});

	describe('regenerate', () => {
		it('should regenerate files even after successful migration', async () => {
			// First migration
			await service.migrate();
			expect(service.getMigrationStatus()).toBe(MigrationStatus.Completed);

			// Regenerate
			const result = await service.regenerate();

			expect(result.status).toBe(MigrationStatus.Completed);
			// 3 builtin agents (agent skipped) + 4 commands + CLAUDE.md + settings.json = 9 files
			expect(result.generatedFiles).toHaveLength(9);
		});

		it('should clear cached agent definitions', async () => {
			// Get definitions to cache them
			const agents1 = await service.getAgentDefinitions();

			// Regenerate should clear cache
			await service.regenerate();

			const agents2 = await service.getAgentDefinitions();

			// Both should have the same built-in agents
			expect(agents1.length).toBe(agents2.length);
		});
	});

	describe('getAgentDefinitions', () => {
		it('should return built-in agents', async () => {
			const agents = await service.getAgentDefinitions();
			
			expect(agents.length).toBeGreaterThanOrEqual(4);
			
			const agentNames = agents.map(a => a.name);
			expect(agentNames).toContain('agent');
			expect(agentNames).toContain('architect');
			expect(agentNames).toContain('reviewer');
			expect(agentNames).toContain('repository-researcher');
		});

		it('should mark built-in agents correctly', async () => {
			const agents = await service.getAgentDefinitions();
			
			const builtInAgents = agents.filter(a => a.isBuiltIn);
			expect(builtInAgents.length).toBe(4);
		});

		it('should cache agent definitions', async () => {
			const agents1 = await service.getAgentDefinitions();
			const agents2 = await service.getAgentDefinitions();
			
			// Same reference means cached
			expect(agents1).toBe(agents2);
		});
	});

	describe('agent file parsing', () => {
		it('should parse agent file with frontmatter', async () => {
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'TestAgent.agent.md'
			);
			mockFs.setFile(agentPath, 
				'---\n' +
				'name: test-agent\n' +
				'description: Test agent description\n' +
				'---\n' +
				'\n' +
				'Instructions for the test agent.'
			);
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const customAgent = agents.find(a => a.name === 'test-agent');
			
			expect(customAgent).toBeDefined();
			expect(customAgent!.description).toBe('Test agent description');
			expect(customAgent!.slashCommand).toBe('/test-agent');
			expect(customAgent!.isBuiltIn).toBe(false);
		});

		it('should derive name from filename when not in frontmatter', async () => {
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'MyFancyAgent.agent.md'
			);
			mockFs.setFile(agentPath, 'Just some instructions without frontmatter.');
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const customAgent = agents.find(a => a.slashCommand === '/my-fancy-agent');
			
			expect(customAgent).toBeDefined();
			expect(customAgent!.name).toBe('my-fancy-agent');
		});

		it('should not duplicate built-in agents from custom files', async () => {
			// Create a file named like a built-in agent
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'Architect.agent.md'
			);
			mockFs.setFile(agentPath, 
				'---\n' +
				'name: architect\n' +
				'---\n' +
				'Custom architect override.'
			);
			
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);
			
			const agents = await service.getAgentDefinitions();
			const architectAgents = agents.filter(a => a.name === 'architect');
			
			// Should only have the built-in one
			expect(architectAgents).toHaveLength(1);
			expect(architectAgents[0].isBuiltIn).toBe(true);
		});
	});

	describe('command file generation', () => {
		it('should generate command files for all agents', async () => {
			const result = await service.migrate();

			expect(result.status).toBe(MigrationStatus.Completed);

			// Check that command file was created for agent
			const commandPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'commands', 'agent.md'
			);
			const content = mockFs.getFile(commandPath);

			expect(content).toBeDefined();
			expect(content).toContain('---');
			expect(content).toContain('name: agent');
			expect(content).toContain('description:');
			expect(content).toContain('argument-hint:');
			expect(content).toContain('@agent');
		});

		it('should generate command files for custom agents', async () => {
			// Create a custom agent file
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'MyCustomAgent.agent.md'
			);
			mockFs.setFile(agentPath,
				'---\n' +
				'name: my-custom-agent\n' +
				'description: A custom agent for testing\n' +
				'---\n' +
				'\n' +
				'This is a custom agent that does custom things.'
			);

			// Mark the directory as existing
			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);

			const result = await service.migrate();
			expect(result.status).toBe(MigrationStatus.Completed);

			// Check custom agent command file
			const commandPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'commands', 'my-custom-agent.md'
			);
			const content = mockFs.getFile(commandPath);

			expect(content).toBeDefined();
			expect(content).toContain('name: my-custom-agent');
			expect(content).toContain('@my-custom-agent');
		});
	});

	describe('agent file generation', () => {
		it('should generate agent files with YAML frontmatter', async () => {
			await service.migrate();

			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'agents', 'builtin', 'architect.md'
			);
			const content = mockFs.getFile(agentPath);

			expect(content).toBeDefined();
			expect(content).toContain('---\nname: architect');
			expect(content).toContain('description:');
			expect(content).toContain('---');
		});

		it('should place custom agents in custom category folder', async () => {
			// Create a custom agent file
			const agentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'agents',
				'CustomAgent.agent.md'
			);
			mockFs.setFile(agentPath,
				'---\n' +
				'name: custom-agent\n' +
				'description: A custom agent\n' +
				'---\n' +
				'Custom instructions here.'
			);

			const agentDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'agents');
			await mockFs.createDirectory(agentDir);

			await service.migrate();

			// Should be in custom folder
			const customAgentPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'agents', 'custom', 'custom-agent.md'
			);
			const content = mockFs.getFile(customAgentPath);

			expect(content).toBeDefined();
			expect(content).toContain('name: custom-agent');
		});
	});

	describe('skills migration', () => {
		it('should migrate skills from .github/skills/ to .claude/skills/', async () => {
			// Create a skill in .github/skills/
			const skillPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.github',
				'skills',
				'my-skill',
				'SKILL.md'
			);
			mockFs.setFile(skillPath,
				'---\n' +
				'name: my-skill\n' +
				'description: A test skill\n' +
				'---\n' +
				'\n' +
				'This skill helps with testing.'
			);

			// Mark directory as existing
			const skillDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'skills', 'my-skill');
			await mockFs.createDirectory(skillDir);
			const skillsDir = URI.joinPath(URI.file('/test/workspace'), '.github', 'skills');
			await mockFs.createDirectory(skillsDir);

			// We need to mock readDirectory to return the skill folder
			const originalReadDirectory = mockFs.readDirectory.bind(mockFs);
			mockFs.readDirectory = async (uri: URI) => {
				const path = uri.toString();
				if (path.includes('.github/skills') && !path.includes('my-skill')) {
					return [['my-skill', 2] as [string, FileType]]; // Directory type
				}
				return originalReadDirectory(uri);
			};

			const result = await service.migrate();
			expect(result.status).toBe(MigrationStatus.Completed);

			// Check skill was migrated
			const migratedSkillPath = URI.joinPath(
				URI.file('/test/workspace'),
				'.claude', 'skills', 'my-skill', 'SKILL.md'
			);
			const content = mockFs.getFile(migratedSkillPath);

			expect(content).toBeDefined();
			expect(content).toContain('name: my-skill');
			expect(content).toContain('This skill helps with testing.');
		});
	});

	describe('content generation', () => {
		it('should include version marker in generated files', async () => {
			await service.migrate();

			// CLAUDE.md is now at workspace root
			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);

			expect(content).toBeDefined();
			// Version is now 1.2.0
			expect(content).toContain('<!-- Migration Version: 1.2.0 -->');
		});

		it('should include available commands section', async () => {
			await service.migrate();

			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);

			expect(content).toBeDefined();
			expect(content).toContain('## Available Commands');
			expect(content).toContain('Built-in Agents');
		});

		it('should include regeneration instructions', async () => {
			await service.migrate();

			const claudeMdPath = URI.joinPath(
				URI.file('/test/workspace'),
				'CLAUDE.md'
			);
			const content = mockFs.getFile(claudeMdPath);

			expect(content).toBeDefined();
			expect(content).toContain('Copilot: Regenerate Claude Configuration');
		});
	});
});
