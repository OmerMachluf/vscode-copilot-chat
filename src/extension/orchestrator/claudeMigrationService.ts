/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import { createDecorator } from '../../util/vs/platform/instantiation/common/instantiation';
import { IFileSystemService } from '../../platform/filesystem/common/fileSystemService';
import { ILogService } from '../../platform/log/common/logService';
import { URI } from '../../util/vs/base/common/uri';
import { Disposable } from '../../util/vs/base/common/lifecycle';

/**
 * Current migration version - increment when migration format changes
 */
export const MIGRATION_VERSION = '1.2.0';

/**
 * Path to generated Claude configuration files
 * These match the Claude Code CLI expected structure:
 * - .claude/agents/{category}/{agent-name}.md - Agent definitions
 * - .claude/commands/{name}.md - Custom slash commands
 * - .claude/skills/{name}/SKILL.md - Skill definitions
 * - CLAUDE.md - Project instructions at workspace root
 */
export const CLAUDE_CONFIG_DIR = '.claude';
export const CLAUDE_AGENTS_DIR = '.claude/agents';
export const CLAUDE_COMMANDS_DIR = '.claude/commands';
export const CLAUDE_SKILLS_DIR = '.claude/skills';
export const CLAUDE_MD_FILENAME = 'CLAUDE.md';
export const CLAUDE_SETTINGS_FILENAME = 'settings.json';

/**
 * Agent categories for folder organization
 */
export const AGENT_CATEGORY_BUILTIN = 'builtin';
export const AGENT_CATEGORY_CUSTOM = 'custom';

/**
 * Legacy path (for cleanup)
 */
export const LEGACY_CLAUDE_CONFIG_PATH = '.github/claude';

/**
 * Auto-generation marker to detect if file was generated by us
 */
export const AUTO_GENERATED_MARKER = '<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->';
export const VERSION_MARKER_PREFIX = '<!-- Migration Version: ';

/**
 * Migration status enum
 */
export enum MigrationStatus {
	Pending = 'pending',
	InProgress = 'in-progress',
	Completed = 'completed',
	Failed = 'failed',
	NotNeeded = 'not-needed'
}

/**
 * Agent definition for CLAUDE.md generation
 */
export interface AgentDefinition {
	/** Agent name (e.g., 'agent', 'architect') */
	name: string;
	/** Human-readable description */
	description: string;
	/** Claude slash command (e.g., '/agent') */
	slashCommand: string;
	/** Whether this is a built-in agent */
	isBuiltIn: boolean;
	/** Source file path (for custom agents) */
	sourcePath?: string;
	/** Agent prompt/personality (the content after frontmatter in .agent.md) */
	agentPrompt?: string;
	/** Tools the agent has access to */
	tools?: string[];
	/** Whether agent has architecture access */
	hasArchitectureAccess?: boolean;
	/** Instruction files content from .github/agents/{agent-name}/ (recursive *.instructions.md) */
	instructionFiles?: string[];
	/** Category for folder organization (builtin, custom, etc.) */
	category?: string;
	/** Raw frontmatter for additional fields */
	rawFrontmatter?: Record<string, unknown>;
}

/**
 * Skill definition for skills migration
 */
export interface SkillDefinition {
	/** Skill ID (folder name) */
	id: string;
	/** Display name */
	name: string;
	/** Description */
	description: string;
	/** Full content of SKILL.md */
	content: string;
	/** Source path */
	sourcePath: string;
}

/**
 * Migration result
 */
export interface MigrationResult {
	status: MigrationStatus;
	generatedFiles: string[];
	error?: string;
}

/**
 * Service identifier for Claude migration
 */
export const IClaudeMigrationService = createDecorator<IClaudeMigrationService>('claudeMigrationService');

/**
 * Service for migrating/generating Claude Code configuration files
 */
export interface IClaudeMigrationService {
	readonly _serviceBrand: undefined;

	/**
	 * Check if migration should be performed
	 */
	shouldMigrate(): Promise<boolean>;

	/**
	 * Perform the migration
	 */
	migrate(): Promise<MigrationResult>;

	/**
	 * Get current migration status
	 */
	getMigrationStatus(): MigrationStatus;

	/**
	 * Force regeneration of Claude configuration files
	 */
	regenerate(): Promise<MigrationResult>;

	/**
	 * Get all agent definitions (built-in + custom)
	 */
	getAgentDefinitions(): Promise<AgentDefinition[]>;
}

/**
 * Built-in agent names that we generate Claude config for.
 * These correspond to files in assets/agents/*.agent.md
 */
const BUILTIN_AGENT_NAMES = [
	'agent',
	'architect',
	'reviewer',
	'repository-researcher',
	'orchestrator',
	'product',
	'researcher',
	'tester',
];

/**
 * The default agent - we only create a command for it, not a separate agent file
 * since it's the default all-capable coding agent
 */
const DEFAULT_AGENT_NAME = 'agent';

export class ClaudeMigrationService extends Disposable implements IClaudeMigrationService {
	declare readonly _serviceBrand: undefined;

	private _status: MigrationStatus = MigrationStatus.Pending;
	private _cachedAgentDefinitions: AgentDefinition[] | undefined;
	private _extensionUri: URI | undefined;

	constructor(
		@IFileSystemService private readonly _fileSystemService: IFileSystemService,
		@ILogService private readonly _logService: ILogService
	) {
		super();
	}

	/**
	 * Set the extension URI to enable loading built-in agents from assets
	 */
	setExtensionUri(extensionUri: URI): void {
		this._extensionUri = extensionUri;
	}

	async shouldMigrate(): Promise<boolean> {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (!workspaceFolders || workspaceFolders.length === 0) {
			return false;
		}

		const workspaceRoot = workspaceFolders[0].uri;

		// Check if CLAUDE.md exists at workspace root
		const claudeMdPath = URI.joinPath(workspaceRoot, CLAUDE_MD_FILENAME);
		const claudeMdExists = await this._exists(claudeMdPath);

		// If CLAUDE.md doesn't exist, we need to migrate
		if (!claudeMdExists) {
			return true;
		}

		// Check if CLAUDE.md is auto-generated and what version
		try {
			const content = await this._readFileAsString(claudeMdPath);
			if (content.includes(AUTO_GENERATED_MARKER)) {
				// Check version - if outdated, migrate
				const versionMatch = content.match(/<!-- Migration Version: ([\d.]+) -->/);
				if (!versionMatch || versionMatch[1] !== MIGRATION_VERSION) {
					return true;
				}
			}
			// Note: If CLAUDE.md exists but wasn't auto-generated by us,
			// we still replace it (policy: CLAUDE.md is always ours)
			// Fall through to check if source files changed or files are missing
		} catch {
			// Can't read file - migrate to recreate it
			return true;
		}

		// Check if any expected command files are missing
		// We always generate commands for all builtin agents
		const commandsDir = URI.joinPath(workspaceRoot, CLAUDE_COMMANDS_DIR);
		for (const agentName of BUILTIN_AGENT_NAMES) {
			const commandPath = URI.joinPath(commandsDir, `${agentName}.md`);
			if (!await this._exists(commandPath)) {
				return true; // Missing command file
			}
		}

		// Check if any expected agent files are missing (except 'agent' which is skipped)
		const agentsDir = URI.joinPath(workspaceRoot, CLAUDE_AGENTS_DIR, AGENT_CATEGORY_BUILTIN);
		for (const agentName of BUILTIN_AGENT_NAMES) {
			if (agentName === DEFAULT_AGENT_NAME) {
				continue; // Skip default agent - no agent file for it
			}
			const agentPath = URI.joinPath(agentsDir, `${agentName}.md`);
			if (!await this._exists(agentPath)) {
				return true; // Missing agent file
			}
		}

		// Check if .github/agents or .github/instructions have newer files
		const needsSync = await this._checkSourceFilesChanged(workspaceRoot);
		return needsSync;
	}

	/**
	 * Check if source files in .github/agents/ are newer than generated files
	 */
	private async _checkSourceFilesChanged(workspaceRoot: URI): Promise<boolean> {
		try {
			const agentsDir = URI.joinPath(workspaceRoot, '.github', 'agents');
			if (!await this._exists(agentsDir)) {
				return false;
			}

			// Get modification time of generated CLAUDE.md
			const claudeMdPath = URI.joinPath(workspaceRoot, CLAUDE_MD_FILENAME);
			let claudeMdMtime = 0;
			try {
				const stat = await this._fileSystemService.stat(claudeMdPath);
				claudeMdMtime = stat.mtime;
			} catch {
				// File doesn't exist
				return true;
			}

			// Check if any agent file is newer
			const entries = await this._fileSystemService.readDirectory(agentsDir);
			for (const [name] of entries) {
				if (name.endsWith('.agent.md')) {
					const agentPath = URI.joinPath(agentsDir, name);
					const stat = await this._fileSystemService.stat(agentPath);
					if (stat.mtime > claudeMdMtime) {
						return true;
					}
				}
			}

			// Check .github/instructions as well
			const instructionsDir = URI.joinPath(workspaceRoot, '.github', 'instructions');
			if (await this._exists(instructionsDir)) {
				const instructionEntries = await this._fileSystemService.readDirectory(instructionsDir);
				for (const [name] of instructionEntries) {
					if (name.endsWith('.md')) {
						const instPath = URI.joinPath(instructionsDir, name);
						const stat = await this._fileSystemService.stat(instPath);
						if (stat.mtime > claudeMdMtime) {
							return true;
						}
					}
				}
			}

			return false;
		} catch {
			return false;
		}
	}

	getMigrationStatus(): MigrationStatus {
		return this._status;
	}

	async migrate(): Promise<MigrationResult> {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (!workspaceFolders || workspaceFolders.length === 0) {
			return { status: MigrationStatus.NotNeeded, generatedFiles: [] };
		}

		if (this._status === MigrationStatus.InProgress) {
			return { status: MigrationStatus.InProgress, generatedFiles: [] };
		}

		this._status = MigrationStatus.InProgress;
		const generatedFiles: string[] = [];

		try {
			const workspaceRoot = workspaceFolders[0].uri;

			// Ensure .claude directory structure exists
			const claudeDir = URI.joinPath(workspaceRoot, CLAUDE_CONFIG_DIR);
			await this._fileSystemService.createDirectory(claudeDir);

			// Ensure .claude/agents/{category} directories exist
			const agentsDir = URI.joinPath(workspaceRoot, CLAUDE_AGENTS_DIR);
			await this._fileSystemService.createDirectory(agentsDir);
			const builtinAgentsDir = URI.joinPath(agentsDir, AGENT_CATEGORY_BUILTIN);
			await this._fileSystemService.createDirectory(builtinAgentsDir);
			const customAgentsDir = URI.joinPath(agentsDir, AGENT_CATEGORY_CUSTOM);
			await this._fileSystemService.createDirectory(customAgentsDir);

			// Ensure .claude/commands directory exists
			const commandsDir = URI.joinPath(workspaceRoot, CLAUDE_COMMANDS_DIR);
			await this._fileSystemService.createDirectory(commandsDir);

			// Get all agent definitions
			const agents = await this.getAgentDefinitions();

			// Generate agent files in Claude format (.claude/agents/{category}/{name}.md)
			// Skip the default agent - it's the all-capable coding agent, no separate definition needed
			for (const agent of agents) {
				if (agent.name.toLowerCase() === DEFAULT_AGENT_NAME) {
					continue; // Skip default agent file - command only
				}
				const agentContent = this._generateAgentFile(agent);
				const category = agent.isBuiltIn ? AGENT_CATEGORY_BUILTIN : AGENT_CATEGORY_CUSTOM;
				const agentPath = URI.joinPath(agentsDir, category, `${agent.name}.md`);
				await this._writeFile(agentPath, agentContent);
				generatedFiles.push(agentPath.toString());
			}

			// Generate command files for ALL agents (both builtin and custom)
			// This includes the default agent - commands can have custom instructions
			for (const agent of agents) {
				const commandContent = this._generateCommandFile(agent);
				const commandPath = URI.joinPath(commandsDir, `${agent.name}.md`);
				await this._writeFile(commandPath, commandContent);
				generatedFiles.push(commandPath.toString());
			}

			// Load and migrate skills from .github/skills/
			const skills = await this._loadSkills(workspaceRoot);
			if (skills.length > 0) {
				const skillsDir = URI.joinPath(workspaceRoot, CLAUDE_SKILLS_DIR);
				await this._fileSystemService.createDirectory(skillsDir);

				for (const skill of skills) {
					const skillDir = URI.joinPath(skillsDir, skill.id);
					await this._fileSystemService.createDirectory(skillDir);
					const skillContent = this._generateSkillFile(skill);
					const skillPath = URI.joinPath(skillDir, 'SKILL.md');
					await this._writeFile(skillPath, skillContent);
					generatedFiles.push(skillPath.toString());
				}
			}

			// Load global instructions from .github/instructions/
			const globalInstructions = await this._loadGlobalInstructions(workspaceRoot);

			// Generate CLAUDE.md at workspace root with project context
			const claudeMdContent = this._generateClaudeMd(agents, globalInstructions);
			const claudeMdPath = URI.joinPath(workspaceRoot, CLAUDE_MD_FILENAME);
			await this._writeFile(claudeMdPath, claudeMdContent);
			generatedFiles.push(claudeMdPath.toString());

			// Generate .claude/settings.json with MCP server config for A2A tools
			const settingsContent = this._generateSettingsJson();
			const settingsPath = URI.joinPath(claudeDir, CLAUDE_SETTINGS_FILENAME);
			await this._writeFile(settingsPath, settingsContent);
			generatedFiles.push(settingsPath.toString());

			this._status = MigrationStatus.Completed;
			this._logService.info(`Claude migration completed. Generated ${generatedFiles.length} files.`);

			return { status: MigrationStatus.Completed, generatedFiles };
		} catch (error) {
			this._status = MigrationStatus.Failed;
			const errorMessage = error instanceof Error ? error.message : String(error);
			this._logService.error(`Claude migration failed: ${errorMessage}`);
			return { status: MigrationStatus.Failed, generatedFiles, error: errorMessage };
		}
	}

	/**
	 * Load global instructions from .github/instructions/*.md
	 */
	private async _loadGlobalInstructions(workspaceRoot: URI): Promise<string[]> {
		const instructions: string[] = [];

		try {
			const instructionsDir = URI.joinPath(workspaceRoot, '.github', 'instructions');
			if (!await this._exists(instructionsDir)) {
				return instructions;
			}

			const entries = await this._fileSystemService.readDirectory(instructionsDir);
			const mdFiles = entries
				.filter(([name]) => name.endsWith('.md'))
				.sort(([a], [b]) => a.localeCompare(b));

			for (const [name] of mdFiles) {
				const filePath = URI.joinPath(instructionsDir, name);
				const content = await this._readFileAsString(filePath);
				if (content.trim()) {
					instructions.push(content.trim());
				}
			}
		} catch {
			// Directory doesn't exist or can't be read
		}

		return instructions;
	}

	/**
	 * Generate an agent file in Claude format with YAML frontmatter
	 * Format: .claude/agents/{category}/{name}.md
	 *
	 * Contains: name, description, tools, hasArchitectureAccess + agent prompt
	 */
	private _generateAgentFile(agent: AgentDefinition): string {
		const lines: string[] = ['---'];

		// Add name
		lines.push(`name: ${agent.name}`);

		// Add description
		lines.push(`description: ${this._escapeYamlString(agent.description)}`);

		// Add tools if present
		if (agent.tools && agent.tools.length > 0) {
			const toolsStr = agent.tools.map(t => `'${t}'`).join(', ');
			lines.push(`tools: [${toolsStr}]`);
		}

		// Add hasArchitectureAccess if present
		if (agent.hasArchitectureAccess !== undefined) {
			lines.push(`hasArchitectureAccess: ${agent.hasArchitectureAccess}`);
		}

		// Add any other raw frontmatter fields
		if (agent.rawFrontmatter) {
			for (const [key, value] of Object.entries(agent.rawFrontmatter)) {
				// Skip fields we've already added
				if (['name', 'description', 'tools', 'hasArchitectureAccess'].includes(key)) {
					continue;
				}
				if (typeof value === 'string') {
					lines.push(`${key}: ${this._escapeYamlString(value)}`);
				} else if (typeof value === 'boolean' || typeof value === 'number') {
					lines.push(`${key}: ${value}`);
				}
			}
		}

		lines.push('---');
		lines.push('');
		lines.push(AUTO_GENERATED_MARKER);
		lines.push(`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`);
		lines.push('');

		// Add agent prompt (the main content after frontmatter)
		if (agent.agentPrompt) {
			lines.push(agent.agentPrompt);
			lines.push('');
		}

		return lines.join('\n');
	}

	/**
	 * Generate a command file in Claude format with YAML frontmatter
	 * Format: .claude/commands/{name}.md
	 *
	 * Contains: Reference to agent + all instruction files from .github/agents/{name}/ (recursive .instructions.md)
	 */
	private _generateCommandFile(agent: AgentDefinition): string {
		const lines: string[] = [
			'---',
			`name: ${agent.name}`,
			`description: ${this._escapeYamlString(agent.description)}`,
			`argument-hint: "[optional: additional context or requirements]"`,
			'---',
			'',
			AUTO_GENERATED_MARKER,
			`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`,
			'',
			`Use the @${agent.name} agent to handle this request.`,
			'',
		];

		// Include instruction files if present
		if (agent.instructionFiles && agent.instructionFiles.length > 0) {
			lines.push('## Instructions');
			lines.push('');
			for (const instruction of agent.instructionFiles) {
				lines.push(instruction);
				lines.push('');
				lines.push('---');
				lines.push('');
			}
		}

		return lines.join('\n');
	}

	/**
	 * Generate a skill file in Claude format with YAML frontmatter
	 * Format: .claude/skills/{name}/SKILL.md
	 */
	private _generateSkillFile(skill: SkillDefinition): string {
		const lines: string[] = [
			'---',
			`name: ${skill.name}`,
			`description: ${this._escapeYamlString(skill.description)}`,
			'---',
			'',
			AUTO_GENERATED_MARKER,
			`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`,
			'',
			skill.content,
		];

		return lines.join('\n');
	}

	/**
	 * Escape special characters in YAML strings
	 */
	private _escapeYamlString(str: string): string {
		// If string contains special characters, wrap in quotes
		if (str.includes(':') || str.includes('#') || str.includes('\n') || str.includes('"') || str.includes("'")) {
			// Replace any internal double quotes and wrap in double quotes
			return `"${str.replace(/"/g, '\\"').replace(/\n/g, ' ')}"`;
		}
		return str;
	}

	/**
	 * Load skills from .github/skills/
	 */
	private async _loadSkills(workspaceRoot: URI): Promise<SkillDefinition[]> {
		const skills: SkillDefinition[] = [];

		try {
			const skillsDir = URI.joinPath(workspaceRoot, '.github', 'skills');
			if (!await this._exists(skillsDir)) {
				return skills;
			}

			const entries = await this._fileSystemService.readDirectory(skillsDir);

			for (const [name, type] of entries) {
				// Skills are in subdirectories
				if (type === 2) { // FileType.Directory
					const skillPath = URI.joinPath(skillsDir, name, 'SKILL.md');
					if (await this._exists(skillPath)) {
						const content = await this._readFileAsString(skillPath);
						const parsed = this._parseSkillFile(content, name);
						if (parsed) {
							skills.push({
								...parsed,
								sourcePath: skillPath.toString(),
							});
						}
					}
				}
			}
		} catch {
			// Skills directory doesn't exist or can't be read
		}

		return skills;
	}

	/**
	 * Parse a skill file to extract metadata
	 */
	private _parseSkillFile(content: string, folderId: string): Omit<SkillDefinition, 'sourcePath'> | undefined {
		// Try to parse YAML frontmatter
		const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
		let name = folderId;
		let description = 'Custom skill';

		if (frontmatterMatch) {
			const frontmatter = frontmatterMatch[1];

			const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
			if (nameMatch) {
				name = nameMatch[1].trim();
			}

			const descMatch = frontmatter.match(/^description:\s*(.+)$/m);
			if (descMatch) {
				description = descMatch[1].trim();
			}
		}

		// Get content after frontmatter
		let skillContent: string;
		if (frontmatterMatch) {
			skillContent = content.substring(frontmatterMatch[0].length).trim();
		} else {
			skillContent = content.trim();
		}

		return {
			id: folderId,
			name,
			description,
			content: skillContent,
		};
	}

	/**
	 * Generate .claude/settings.json
	 */
	private _generateSettingsJson(): string {
		const settings = {
			// Note: This is a placeholder for any Claude Code CLI settings
			// The A2A MCP server is wired in-process, not via external config
			_comment: 'Auto-generated by GitHub Copilot extension',
			_version: MIGRATION_VERSION,
		};

		return JSON.stringify(settings, null, 2);
	}

	async regenerate(): Promise<MigrationResult> {
		// Clear cached definitions
		this._cachedAgentDefinitions = undefined;
		// Reset status to allow migration
		this._status = MigrationStatus.Pending;
		// Perform migration
		return this.migrate();
	}

	async getAgentDefinitions(): Promise<AgentDefinition[]> {
		if (this._cachedAgentDefinitions) {
			return this._cachedAgentDefinitions;
		}

		const agents: AgentDefinition[] = [];
		const workspaceFolders = vscode.workspace.workspaceFolders;
		const workspaceRoot = workspaceFolders?.[0]?.uri;

		// Load built-in agents from assets/agents/*.agent.md
		const builtinAgents = await this._loadBuiltinAgents();

		// For each built-in agent, also load instruction files from .github/agents/{name}/
		for (const agent of builtinAgents) {
			if (workspaceRoot) {
				const instructionFiles = await this._loadInstructionFiles(workspaceRoot, agent.name);
				if (instructionFiles.length > 0) {
					agent.instructionFiles = instructionFiles;
				}
			}
			agents.push(agent);
		}

		// Load custom agents from .github/agents/
		if (workspaceRoot) {
			const customAgents = await this._loadCustomAgents(workspaceRoot);
			for (const customAgent of customAgents) {
				// Don't add if it would duplicate a built-in agent
				if (!agents.some(a => a.name.toLowerCase() === customAgent.name.toLowerCase())) {
					agents.push(customAgent);
				}
			}
		}

		this._cachedAgentDefinitions = agents;
		return agents;
	}

	/**
	 * Load built-in agents from assets/agents/*.agent.md
	 */
	private async _loadBuiltinAgents(): Promise<AgentDefinition[]> {
		const agents: AgentDefinition[] = [];

		// Try to load from assets if extension URI is available
		if (this._extensionUri) {
			const assetsDir = URI.joinPath(this._extensionUri, 'assets', 'agents');
			this._logService.info(`[Claude Migration] Loading builtin agents from: ${assetsDir.toString()}`);

			for (const name of BUILTIN_AGENT_NAMES) {
				try {
					// Try different filename patterns (Agent.agent.md, agent.agent.md, etc.)
					const fileNames = [
						`${name.charAt(0).toUpperCase() + name.slice(1)}.agent.md`, // Agent.agent.md
						`${this._toPascalCase(name)}.agent.md`, // RepositoryResearcher.agent.md
						`${name}.agent.md`, // agent.agent.md
					];

					let loaded = false;
					for (const fileName of fileNames) {
						try {
							const filePath = URI.joinPath(assetsDir, fileName);
							const content = await this._readFileAsString(filePath);
							const parsed = this._parseAgentFile(content, fileName);

							if (parsed) {
								this._logService.info(`[Claude Migration] Loaded agent ${name} from ${fileName}`);
								agents.push({
									...parsed,
									name: name.toLowerCase(), // Normalize name
									slashCommand: `/${name.toLowerCase()}`,
									isBuiltIn: true,
									category: AGENT_CATEGORY_BUILTIN,
									sourcePath: filePath.toString(),
								});
								loaded = true;
								break;
							}
						} catch (e) {
							// Try next filename
							this._logService.trace(`[Claude Migration] Could not load ${fileName}: ${e}`);
						}
					}

					if (!loaded) {
						// Fallback if file not found
						this._logService.warn(`[Claude Migration] Using fallback for agent: ${name}`);
						agents.push(this._createFallbackAgent(name));
					}
				} catch {
					// Fallback if loading fails
					agents.push(this._createFallbackAgent(name));
				}
			}
		} else {
			// No extension URI - use fallback definitions
			this._logService.info('[Claude Migration] No extension URI, using fallback agents');
			for (const name of BUILTIN_AGENT_NAMES) {
				agents.push(this._createFallbackAgent(name));
			}
		}

		return agents;
	}

	/**
	 * Create a fallback agent definition when the actual file can't be loaded
	 */
	private _createFallbackAgent(name: string): AgentDefinition {
		return {
			name: name.toLowerCase(),
			description: `Built-in ${name} agent`,
			slashCommand: `/${name.toLowerCase()}`,
			isBuiltIn: true,
			category: AGENT_CATEGORY_BUILTIN,
			agentPrompt: `You are the ${name} agent.`,
		};
	}

	/**
	 * Convert kebab-case or lowercase to PascalCase
	 */
	private _toPascalCase(str: string): string {
		return str
			.split('-')
			.map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
			.join('');
	}

	/**
	 * Load instruction files from .github/agents/{agentName}/ (recursive .instructions.md)
	 */
	private async _loadInstructionFiles(workspaceRoot: URI, agentName: string): Promise<string[]> {
		const instructions: string[] = [];

		try {
			const agentDir = URI.joinPath(workspaceRoot, '.github', 'agents', agentName.toLowerCase());
			if (!await this._exists(agentDir)) {
				return instructions;
			}

			// Recursively find all .instructions.md files
			await this._collectInstructionFiles(agentDir, instructions);
		} catch {
			// Directory doesn't exist or can't be read
		}

		return instructions;
	}

	/**
	 * Recursively collect .instructions.md files from a directory
	 */
	private async _collectInstructionFiles(dir: URI, instructions: string[]): Promise<void> {
		try {
			const entries = await this._fileSystemService.readDirectory(dir);

			for (const [name, type] of entries) {
				const path = URI.joinPath(dir, name);

				if (type === 2) { // Directory
					// Recurse into subdirectories
					await this._collectInstructionFiles(path, instructions);
				} else if (name.endsWith('.instructions.md')) {
					// Load instruction file
					const content = await this._readFileAsString(path);
					if (content.trim()) {
						instructions.push(content.trim());
					}
				}
			}
		} catch {
			// Ignore errors reading directories
		}
	}

	/**
	 * Load custom agents from .github/agents/
	 */
	private async _loadCustomAgents(workspaceRoot: URI): Promise<AgentDefinition[]> {
		const customAgents: AgentDefinition[] = [];

		try {
			const agentsDir = URI.joinPath(workspaceRoot, '.github', 'agents');

			if (!await this._exists(agentsDir)) {
				return customAgents;
			}

			const entries = await this._fileSystemService.readDirectory(agentsDir);

			for (const [name, type] of entries) {
				// Handle .agent.md files at the root level
				if (name.endsWith('.agent.md')) {
					const agentPath = URI.joinPath(agentsDir, name);
					const content = await this._readFileAsString(agentPath);
					const parsed = this._parseAgentFile(content, name);

					if (parsed) {
						// Also load instruction files for this agent
						const instructionFiles = await this._loadInstructionFiles(workspaceRoot, parsed.name);

						customAgents.push({
							...parsed,
							isBuiltIn: false,
							category: AGENT_CATEGORY_CUSTOM,
							sourcePath: agentPath.toString(),
							instructionFiles: instructionFiles.length > 0 ? instructionFiles : undefined,
						});
					}
				}
				// Handle agent subdirectories (may contain .agent.md + .instructions.md files)
				else if (type === 2) { // FileType.Directory
					// Skip directories that match built-in agent names (those are for instructions only)
					if (BUILTIN_AGENT_NAMES.includes(name.toLowerCase())) {
						continue;
					}

					const agentSubDir = URI.joinPath(agentsDir, name);
					const agent = await this._loadAgentFromDirectory(agentSubDir, name, workspaceRoot);
					if (agent) {
						customAgents.push(agent);
					}
				}
			}
		} catch (error) {
			this._logService.warn(`Failed to load custom agents: ${error}`);
		}

		return customAgents;
	}

	/**
	 * Load an agent from a subdirectory
	 * Structure: .github/agents/{agent-name}/
	 *   - {agent-name}.agent.md (main definition)
	 *   - *.instructions.md (instruction files, recursive)
	 */
	private async _loadAgentFromDirectory(agentDir: URI, dirName: string, workspaceRoot: URI): Promise<AgentDefinition | undefined> {
		try {
			const entries = await this._fileSystemService.readDirectory(agentDir);
			let mainAgent: AgentDefinition | undefined;

			// Find the main agent file
			for (const [fileName] of entries) {
				if (fileName.endsWith('.agent.md')) {
					const filePath = URI.joinPath(agentDir, fileName);
					const content = await this._readFileAsString(filePath);
					const parsed = this._parseAgentFile(content, fileName);
					if (parsed) {
						mainAgent = {
							...parsed,
							isBuiltIn: false,
							category: AGENT_CATEGORY_CUSTOM,
							sourcePath: filePath.toString(),
						};
						break;
					}
				}
			}

			// If no main agent file found, create one from the directory name
			if (!mainAgent) {
				const agentName = this._toKebabCase(dirName);
				mainAgent = {
					name: agentName,
					description: `Custom agent: ${dirName}`,
					slashCommand: `/${agentName}`,
					isBuiltIn: false,
					category: AGENT_CATEGORY_CUSTOM,
					sourcePath: agentDir.toString(),
				};
			}

			// Load instruction files for this agent
			const instructionFiles = await this._loadInstructionFiles(workspaceRoot, mainAgent.name);
			if (instructionFiles.length > 0) {
				mainAgent.instructionFiles = instructionFiles;
			}

			return mainAgent;
		} catch {
			return undefined;
		}
	}

	private _parseAgentFile(content: string, filename: string): Omit<AgentDefinition, 'isBuiltIn' | 'sourcePath'> | undefined {
		// Try to parse YAML frontmatter
		const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
		let name: string | undefined;
		let description = 'Custom agent';
		let tools: string[] | undefined;
		let hasArchitectureAccess: boolean | undefined;
		const rawFrontmatter: Record<string, unknown> = {};

		if (frontmatterMatch) {
			const frontmatter = frontmatterMatch[1];

			// Parse name
			const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
			if (nameMatch) {
				name = nameMatch[1].trim();
				rawFrontmatter['name'] = name;
			}

			// Parse description
			const descMatch = frontmatter.match(/^description:\s*(.+)$/m);
			if (descMatch) {
				description = descMatch[1].trim();
				rawFrontmatter['description'] = description;
			}

			// Parse tools array
			const toolsMatch = frontmatter.match(/^tools:\s*\[([^\]]*)\]/m);
			if (toolsMatch) {
				tools = toolsMatch[1]
					.split(',')
					.map(t => t.trim().replace(/['"]/g, ''))
					.filter(t => t.length > 0);
				rawFrontmatter['tools'] = tools;
			}

			// Parse hasArchitectureAccess
			const archMatch = frontmatter.match(/^hasArchitectureAccess:\s*(true|false)$/m);
			if (archMatch) {
				hasArchitectureAccess = archMatch[1] === 'true';
				rawFrontmatter['hasArchitectureAccess'] = hasArchitectureAccess;
			}

			// Parse any other fields and store in rawFrontmatter
			const lines = frontmatter.split('\n');
			for (const line of lines) {
				const match = line.match(/^(\w+):\s*(.+)$/);
				if (match && !rawFrontmatter[match[1]]) {
					rawFrontmatter[match[1]] = match[2].trim();
				}
			}
		}

		// Derive name from filename if not in frontmatter
		if (!name) {
			// Convert "MyFancyAgent.agent.md" to "my-fancy-agent"
			const baseName = filename.replace('.agent.md', '');
			name = this._toKebabCase(baseName);
		}

		// Extract agent prompt (everything after frontmatter)
		let agentPrompt: string | undefined;
		if (frontmatterMatch) {
			agentPrompt = content.substring(frontmatterMatch[0].length).trim();
		} else {
			agentPrompt = content.trim();
		}

		return {
			name,
			description,
			slashCommand: `/${name}`,
			agentPrompt,
			tools,
			hasArchitectureAccess,
			rawFrontmatter,
		};
	}

	private _toKebabCase(str: string): string {
		return str
			.replace(/([a-z])([A-Z])/g, '$1-$2')
			.replace(/[\s_]+/g, '-')
			.toLowerCase();
	}

	private _generateClaudeMd(agents: AgentDefinition[], globalInstructions: string[] = []): string {
		const builtInAgents = agents.filter(a => a.isBuiltIn);
		const customAgents = agents.filter(a => !a.isBuiltIn);

		const lines: string[] = [
			AUTO_GENERATED_MARKER,
			`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`,
			'',
			'# Project Instructions for Claude',
			'',
		];

		// Add global instructions from .github/instructions/ first (most important)
		if (globalInstructions.length > 0) {
			lines.push('## Project Guidelines');
			lines.push('');
			for (const instruction of globalInstructions) {
				lines.push(instruction);
				lines.push('');
			}
		}

		// Add custom agent instructions
		if (customAgents.length > 0) {
			lines.push('## Custom Agents');
			lines.push('');
			lines.push('The following custom agents are available as slash commands:');
			lines.push('');

			for (const agent of customAgents) {
				lines.push(`### ${agent.slashCommand}`);
				lines.push('');
				lines.push(`**${agent.description}**`);
				lines.push('');
				if (agent.instructionFiles && agent.instructionFiles.length > 0) {
					for (const instruction of agent.instructionFiles) {
						lines.push(instruction);
						lines.push('');
					}
				}
			}
		}

		// Add available commands reference
		lines.push('## Available Commands');
		lines.push('');
		lines.push('### Built-in Agents');
		lines.push('');
		lines.push('| Command | Description |');
		lines.push('|---------|-------------|');

		for (const agent of builtInAgents) {
			lines.push(`| \`${agent.slashCommand}\` | ${agent.description} |`);
		}

		if (customAgents.length > 0) {
			lines.push('');
			lines.push('### Custom Agents');
			lines.push('');
			lines.push('| Command | Description |');
			lines.push('|---------|-------------|');

			for (const agent of customAgents) {
				lines.push(`| \`${agent.slashCommand}\` | ${agent.description} |`);
			}
		}

		lines.push('');
		lines.push('---');
		lines.push('');
		lines.push('*This file was auto-generated from `.github/agents/` and `.github/instructions/`.*');
		lines.push('*Run `Copilot: Regenerate Claude Configuration` to update.*');
		lines.push('');

		return lines.join('\n');
	}

	private async _readFileAsString(uri: URI): Promise<string> {
		const buffer = await this._fileSystemService.readFile(uri);
		return new TextDecoder().decode(buffer);
	}

	private async _writeFile(uri: URI, content: string): Promise<void> {
		const buffer = new TextEncoder().encode(content);
		await this._fileSystemService.writeFile(uri, buffer);
	}

	private async _exists(uri: URI): Promise<boolean> {
		try {
			await this._fileSystemService.stat(uri);
			return true;
		} catch {
			return false;
		}
	}
}
