/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import { createDecorator } from '../../util/vs/platform/instantiation/common/instantiation';
import { IFileSystemService } from '../../platform/filesystem/common/fileSystemService';
import { ILogService } from '../../platform/log/common/logService';
import { URI } from '../../util/vs/base/common/uri';
import { Disposable } from '../../util/vs/base/common/lifecycle';

/**
 * Current migration version - increment when migration format changes
 */
export const MIGRATION_VERSION = '1.0.0';

/**
 * Path to generated Claude configuration files
 */
export const CLAUDE_CONFIG_PATH = '.github/claude';
export const CLAUDE_MD_FILENAME = 'CLAUDE.md';
export const SLASH_COMMANDS_FILENAME = 'SLASH_COMMANDS.md';

/**
 * Auto-generation marker to detect if file was generated by us
 */
export const AUTO_GENERATED_MARKER = '<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->';
export const VERSION_MARKER_PREFIX = '<!-- Migration Version: ';

/**
 * Migration status enum
 */
export enum MigrationStatus {
	Pending = 'pending',
	InProgress = 'in-progress',
	Completed = 'completed',
	Failed = 'failed',
	NotNeeded = 'not-needed'
}

/**
 * Agent definition for CLAUDE.md generation
 */
export interface AgentDefinition {
	/** Agent name (e.g., 'agent', 'architect') */
	name: string;
	/** Human-readable description */
	description: string;
	/** Claude slash command (e.g., '/agent') */
	slashCommand: string;
	/** Whether this is a built-in agent */
	isBuiltIn: boolean;
	/** Source file path (for custom agents) */
	sourcePath?: string;
	/** Full instructions content */
	instructions?: string;
}

/**
 * Migration result
 */
export interface MigrationResult {
	status: MigrationStatus;
	generatedFiles: string[];
	error?: string;
}

/**
 * Service identifier for Claude migration
 */
export const IClaudeMigrationService = createDecorator<IClaudeMigrationService>('claudeMigrationService');

/**
 * Service for migrating/generating Claude Code configuration files
 */
export interface IClaudeMigrationService {
	readonly _serviceBrand: undefined;

	/**
	 * Check if migration should be performed
	 */
	shouldMigrate(): Promise<boolean>;

	/**
	 * Perform the migration
	 */
	migrate(): Promise<MigrationResult>;

	/**
	 * Get current migration status
	 */
	getMigrationStatus(): MigrationStatus;

	/**
	 * Force regeneration of Claude configuration files
	 */
	regenerate(): Promise<MigrationResult>;

	/**
	 * Get all agent definitions (built-in + custom)
	 */
	getAgentDefinitions(): Promise<AgentDefinition[]>;
}

/**
 * Built-in agents that are always available
 */
const BUILTIN_AGENTS: AgentDefinition[] = [
	{
		name: 'agent',
		description: 'Default Copilot agent for implementing code changes and tasks',
		slashCommand: '/agent',
		isBuiltIn: true,
	},
	{
		name: 'architect',
		description: 'System design and architecture planning specialist',
		slashCommand: '/architect',
		isBuiltIn: true,
	},
	{
		name: 'reviewer',
		description: 'Code review and quality assurance specialist',
		slashCommand: '/reviewer',
		isBuiltIn: true,
	},
	{
		name: 'repository-researcher',
		description: 'Codebase investigation and architecture documentation specialist',
		slashCommand: '/repository-researcher',
		isBuiltIn: true,
	},
];

export class ClaudeMigrationService extends Disposable implements IClaudeMigrationService {
	declare readonly _serviceBrand: undefined;

	private _status: MigrationStatus = MigrationStatus.Pending;
	private _cachedAgentDefinitions: AgentDefinition[] | undefined;

	constructor(
		@IFileSystemService private readonly _fileSystemService: IFileSystemService,
		@ILogService private readonly _logService: ILogService
	) {
		super();
	}

	async shouldMigrate(): Promise<boolean> {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (!workspaceFolders || workspaceFolders.length === 0) {
			return false;
		}

		const workspaceRoot = workspaceFolders[0].uri;
		const claudeMdPath = URI.joinPath(workspaceRoot, CLAUDE_CONFIG_PATH, CLAUDE_MD_FILENAME);

		try {
			const exists = await this._exists(claudeMdPath);
			if (!exists) {
				return true;
			}

			// Check if it's our auto-generated file
			const content = await this._readFileAsString(claudeMdPath);
			if (!content.includes(AUTO_GENERATED_MARKER)) {
				// User-created file, don't overwrite
				return false;
			}

			// Check version
			const versionMatch = content.match(/<!-- Migration Version: ([\d.]+) -->/);
			if (versionMatch) {
				const fileVersion = versionMatch[1];
				return fileVersion !== MIGRATION_VERSION;
			}

			// Auto-generated but no version - needs migration
			return true;
		} catch {
			// File doesn't exist or can't be read
			return true;
		}
	}

	getMigrationStatus(): MigrationStatus {
		return this._status;
	}

	async migrate(): Promise<MigrationResult> {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (!workspaceFolders || workspaceFolders.length === 0) {
			return { status: MigrationStatus.NotNeeded, generatedFiles: [] };
		}

		if (this._status === MigrationStatus.InProgress) {
			return { status: MigrationStatus.InProgress, generatedFiles: [] };
		}

		this._status = MigrationStatus.InProgress;
		const generatedFiles: string[] = [];

		try {
			const workspaceRoot = workspaceFolders[0].uri;
			const claudeDir = URI.joinPath(workspaceRoot, CLAUDE_CONFIG_PATH);

			// Ensure .github/claude directory exists
			await this._fileSystemService.createDirectory(claudeDir);

			// Get all agent definitions
			const agents = await this.getAgentDefinitions();

			// Generate CLAUDE.md
			const claudeMdContent = this._generateClaudeMd(agents);
			const claudeMdPath = URI.joinPath(claudeDir, CLAUDE_MD_FILENAME);
			await this._writeFile(claudeMdPath, claudeMdContent);
			generatedFiles.push(claudeMdPath.toString());

			// Generate SLASH_COMMANDS.md
			const slashCommandsContent = this._generateSlashCommandsMd(agents);
			const slashCommandsPath = URI.joinPath(claudeDir, SLASH_COMMANDS_FILENAME);
			await this._writeFile(slashCommandsPath, slashCommandsContent);
			generatedFiles.push(slashCommandsPath.toString());

			this._status = MigrationStatus.Completed;
			this._logService.info(`Claude migration completed. Generated ${generatedFiles.length} files.`);

			return { status: MigrationStatus.Completed, generatedFiles };
		} catch (error) {
			this._status = MigrationStatus.Failed;
			const errorMessage = error instanceof Error ? error.message : String(error);
			this._logService.error(`Claude migration failed: ${errorMessage}`);
			return { status: MigrationStatus.Failed, generatedFiles, error: errorMessage };
		}
	}

	async regenerate(): Promise<MigrationResult> {
		// Clear cached definitions
		this._cachedAgentDefinitions = undefined;
		// Reset status to allow migration
		this._status = MigrationStatus.Pending;
		// Perform migration
		return this.migrate();
	}

	async getAgentDefinitions(): Promise<AgentDefinition[]> {
		if (this._cachedAgentDefinitions) {
			return this._cachedAgentDefinitions;
		}

		const agents: AgentDefinition[] = [...BUILTIN_AGENTS];

		// Load custom agents from workspace
		const customAgents = await this._loadCustomAgents();
		for (const customAgent of customAgents) {
			// Don't add if it would duplicate a built-in agent
			if (!agents.some(a => a.name === customAgent.name)) {
				agents.push(customAgent);
			}
		}

		this._cachedAgentDefinitions = agents;
		return agents;
	}

	private async _loadCustomAgents(): Promise<AgentDefinition[]> {
		const customAgents: AgentDefinition[] = [];
		const workspaceFolders = vscode.workspace.workspaceFolders;

		if (!workspaceFolders || workspaceFolders.length === 0) {
			return customAgents;
		}

		try {
			const workspaceRoot = workspaceFolders[0].uri;
			const agentsDir = URI.joinPath(workspaceRoot, '.github', 'agents');

			const exists = await this._exists(agentsDir);
			if (!exists) {
				return customAgents;
			}

			const entries = await this._fileSystemService.readDirectory(agentsDir);

			for (const [name, _type] of entries) {
				if (name.endsWith('.agent.md')) {
					const agentPath = URI.joinPath(agentsDir, name);
					const content = await this._readFileAsString(agentPath);
					const parsed = this._parseAgentFile(content, name);

					if (parsed) {
						customAgents.push({
							...parsed,
							isBuiltIn: false,
							sourcePath: agentPath.toString(),
						});
					}
				}
			}
		} catch (error) {
			this._logService.warn(`Failed to load custom agents: ${error}`);
		}

		return customAgents;
	}

	private _parseAgentFile(content: string, filename: string): Omit<AgentDefinition, 'isBuiltIn' | 'sourcePath'> | undefined {
		// Try to parse YAML frontmatter
		const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
		let name: string | undefined;
		let description = 'Custom agent';

		if (frontmatterMatch) {
			const frontmatter = frontmatterMatch[1];

			// Simple YAML parsing for name and description
			const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
			if (nameMatch) {
				name = nameMatch[1].trim();
			}

			const descMatch = frontmatter.match(/^description:\s*(.+)$/m);
			if (descMatch) {
				description = descMatch[1].trim();
			}
		}

		// Derive name from filename if not in frontmatter
		if (!name) {
			// Convert "MyFancyAgent.agent.md" to "my-fancy-agent"
			const baseName = filename.replace('.agent.md', '');
			name = this._toKebabCase(baseName);
		}

		// Extract instructions (everything after frontmatter)
		let instructions: string | undefined;
		if (frontmatterMatch) {
			instructions = content.substring(frontmatterMatch[0].length).trim();
		} else {
			instructions = content.trim();
		}

		return {
			name,
			description,
			slashCommand: `/${name}`,
			instructions,
		};
	}

	private _toKebabCase(str: string): string {
		return str
			.replace(/([a-z])([A-Z])/g, '$1-$2')
			.replace(/[\s_]+/g, '-')
			.toLowerCase();
	}

	private _generateClaudeMd(agents: AgentDefinition[]): string {
		const builtInAgents = agents.filter(a => a.isBuiltIn);
		const customAgents = agents.filter(a => !a.isBuiltIn);

		const lines: string[] = [
			AUTO_GENERATED_MARKER,
			`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`,
			'',
			'# Claude Code Configuration',
			'',
			'This file was automatically generated from your GitHub Copilot agent configuration.',
			'To regenerate, run the VS Code command: `Copilot: Regenerate Claude Configuration`',
			'',
			'## Built-in Agents',
			'',
			'| Command | Description |',
			'|---------|-------------|',
		];

		for (const agent of builtInAgents) {
			lines.push(`| \`${agent.slashCommand}\` | ${agent.description} |`);
		}

		if (customAgents.length > 0) {
			lines.push('');
			lines.push('## Custom Agents');
			lines.push('');
			lines.push('| Command | Description |');
			lines.push('|---------|-------------|');

			for (const agent of customAgents) {
				lines.push(`| \`${agent.slashCommand}\` | ${agent.description} |`);
			}
		}

		lines.push('');
		lines.push('## Usage');
		lines.push('');
		lines.push('Use slash commands to invoke specific agents:');
		lines.push('');
		lines.push('```');
		lines.push('/agent Implement the login feature');
		lines.push('/architect Design a new authentication system');
		lines.push('/reviewer Review my recent changes');
		lines.push('/repository-researcher What patterns does this codebase use?');
		lines.push('```');
		lines.push('');
		lines.push('## Regeneration');
		lines.push('');
		lines.push('This file is auto-generated. To regenerate after adding or modifying agents:');
		lines.push('');
		lines.push('1. Open VS Code Command Palette (`Ctrl+Shift+P` / `Cmd+Shift+P`)');
		lines.push('2. Run: `Copilot: Regenerate Claude Configuration`');
		lines.push('');
		lines.push('Or delete this file to trigger automatic regeneration on next Claude task.');
		lines.push('');

		return lines.join('\n');
	}

	private _generateSlashCommandsMd(agents: AgentDefinition[]): string {
		const lines: string[] = [
			AUTO_GENERATED_MARKER,
			`${VERSION_MARKER_PREFIX}${MIGRATION_VERSION} -->`,
			'',
			'# Slash Commands Reference',
			'',
			'Complete reference for all available slash commands.',
			'',
			'## Commands',
			'',
			'| Command | Description | Type |',
			'|---------|-------------|------|',
		];

		for (const agent of agents) {
			const type = agent.isBuiltIn ? 'Built-in' : 'Custom';
			lines.push(`| \`${agent.slashCommand}\` | ${agent.description} | ${type} |`);
		}

		lines.push('');
		lines.push('## Agent Details');
		lines.push('');

		for (const agent of agents) {
			lines.push(`### ${agent.slashCommand}`);
			lines.push('');
			lines.push(`**Type:** ${agent.isBuiltIn ? 'Built-in' : 'Custom'}`);
			lines.push('');
			lines.push(`**Description:** ${agent.description}`);
			lines.push('');

			if (agent.instructions) {
				lines.push('**Instructions:**');
				lines.push('');
				lines.push('```');
				// Truncate long instructions
				const truncatedInstructions = agent.instructions.length > 500
					? agent.instructions.substring(0, 500) + '...'
					: agent.instructions;
				lines.push(truncatedInstructions);
				lines.push('```');
				lines.push('');
			}
		}

		return lines.join('\n');
	}

	private async _readFileAsString(uri: URI): Promise<string> {
		const buffer = await this._fileSystemService.readFile(uri);
		return new TextDecoder().decode(buffer);
	}

	private async _writeFile(uri: URI, content: string): Promise<void> {
		const buffer = new TextEncoder().encode(content);
		await this._fileSystemService.writeFile(uri, buffer);
	}

	private async _exists(uri: URI): Promise<boolean> {
		try {
			await this._fileSystemService.stat(uri);
			return true;
		} catch {
			return false;
		}
	}
}
