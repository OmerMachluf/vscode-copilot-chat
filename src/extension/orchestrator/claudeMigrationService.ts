/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { CancellationToken, Disposable, Uri } from 'vscode';
import { IFileSystemService } from '../../platform/common/fileSystem';
import { IWorkspace } from '../../platform/common/workspace';
import { createDecorator, IInstantiationService } from '../../util/common/instantiation';
import { ILogService } from '../../platform/common/log';

/**
 * Status of the Claude migration process
 */
export const enum MigrationStatus {
	/** No migration needed */
	NotNeeded = 'notNeeded',
	/** Migration is pending */
	Pending = 'pending',
	/** Migration is in progress */
	InProgress = 'inProgress',
	/** Migration completed successfully */
	Completed = 'completed',
	/** Migration failed */
	Failed = 'failed'
}

/**
 * Result of a migration operation
 */
export interface MigrationResult {
	readonly status: MigrationStatus;
	readonly error?: string;
	readonly generatedFiles: readonly Uri[];
}

/**
 * Agent definition extracted from .agent.md files
 */
export interface AgentDefinition {
	readonly name: string;
	readonly description: string;
	readonly slashCommand: string;
	readonly instructions: string;
	readonly isBuiltIn: boolean;
}

/**
 * Service for managing Claude-specific configuration migration
 * Auto-generates Claude-specific files from .github/agents configuration
 */
export interface IClaudeMigrationService {
	readonly _serviceBrand: undefined;

	/**
	 * Check if migration is needed for the current workspace
	 * Returns true if .github/claude/CLAUDE.md doesn't exist or is outdated
	 */
	shouldMigrate(token?: CancellationToken): Promise<boolean>;

	/**
	 * Perform the migration - generates CLAUDE.md and related files
	 */
	migrate(token?: CancellationToken): Promise<MigrationResult>;

	/**
	 * Get the current migration status
	 */
	getMigrationStatus(): MigrationStatus;

	/**
	 * Force regeneration of Claude configuration files
	 */
	regenerate(token?: CancellationToken): Promise<MigrationResult>;

	/**
	 * Get all discovered agent definitions
	 */
	getAgentDefinitions(token?: CancellationToken): Promise<readonly AgentDefinition[]>;
}

export const IClaudeMigrationService = createDecorator<IClaudeMigrationService>('claudeMigrationService');

/**
 * Marker used in generated files to detect if they were auto-generated
 */
const MIGRATION_MARKER = '<!-- Auto-generated by GitHub Copilot - DO NOT EDIT MANUALLY -->';
const MIGRATION_VERSION_PREFIX = '<!-- Migration Version: ';
const CURRENT_MIGRATION_VERSION = '1.0.0';

/**
 * Built-in agents that are always available
 */
const BUILT_IN_AGENTS: readonly AgentDefinition[] = [
	{
		name: 'agent',
		description: 'Default implementation agent for general coding tasks',
		slashCommand: '/agent',
		instructions: 'General purpose coding assistant.',
		isBuiltIn: true
	},
	{
		name: 'architect',
		description: 'System design and architecture planning',
		slashCommand: '/architect',
		instructions: 'Specializes in system design, architecture decisions, and technical planning.',
		isBuiltIn: true
	},
	{
		name: 'reviewer',
		description: 'Code review and quality analysis',
		slashCommand: '/reviewer',
		instructions: 'Reviews code for quality, best practices, and potential issues.',
		isBuiltIn: true
	},
	{
		name: 'repository-researcher',
		description: 'Codebase investigation and analysis',
		slashCommand: '/repository-researcher',
		instructions: 'Investigates codebase structure, finds relevant code, and answers questions about the repository.',
		isBuiltIn: true
	}
];

/**
 * Service that manages migration of agent configurations to Claude-specific format
 */
export class ClaudeMigrationService implements IClaudeMigrationService {
	readonly _serviceBrand: undefined;

	private _status: MigrationStatus = MigrationStatus.Pending;
	private _cachedAgentDefinitions: AgentDefinition[] | undefined;

	constructor(
		@IFileSystemService private readonly fileSystemService: IFileSystemService,
		@IWorkspace private readonly workspace: IWorkspace,
		@ILogService private readonly logService: ILogService
	) { }

	async shouldMigrate(token?: CancellationToken): Promise<boolean> {
		const workspaceFolder = this.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return false;
		}

		const claudeMdPath = Uri.joinPath(workspaceFolder.uri, '.github', 'claude', 'CLAUDE.md');

		try {
			const exists = await this.fileSystemService.exists(claudeMdPath);
			if (!exists) {
				return true;
			}

			// Check if the file was auto-generated and needs updating
			const content = await this.fileSystemService.readFile(claudeMdPath);
			const text = new TextDecoder().decode(content);

			if (!text.includes(MIGRATION_MARKER)) {
				// Not auto-generated, don't overwrite
				return false;
			}

			// Check version
			const versionMatch = text.match(new RegExp(`${MIGRATION_VERSION_PREFIX}(\\d+\\.\\d+\\.\\d+)`));
			if (!versionMatch) {
				return true; // No version found, needs update
			}

			return versionMatch[1] !== CURRENT_MIGRATION_VERSION;
		} catch (error) {
			this.logService.error('ClaudeMigrationService', 'Error checking migration status', error);
			return true;
		}
	}

	getMigrationStatus(): MigrationStatus {
		return this._status;
	}

	async migrate(token?: CancellationToken): Promise<MigrationResult> {
		if (this._status === MigrationStatus.InProgress) {
			return {
				status: MigrationStatus.InProgress,
				generatedFiles: []
			};
		}

		this._status = MigrationStatus.InProgress;
		const generatedFiles: Uri[] = [];

		try {
			const workspaceFolder = this.workspace.workspaceFolders?.[0];
			if (!workspaceFolder) {
				this._status = MigrationStatus.NotNeeded;
				return {
					status: MigrationStatus.NotNeeded,
					generatedFiles: []
				};
			}

			// Get all agent definitions
			const agents = await this.getAgentDefinitions(token);

			// Generate CLAUDE.md content
			const claudeMdContent = this.generateClaudeMdContent(agents);

			// Ensure directory exists
			const claudeDir = Uri.joinPath(workspaceFolder.uri, '.github', 'claude');
			await this.fileSystemService.createDirectory(claudeDir);

			// Write CLAUDE.md
			const claudeMdPath = Uri.joinPath(claudeDir, 'CLAUDE.md');
			await this.fileSystemService.writeFile(claudeMdPath, new TextEncoder().encode(claudeMdContent));
			generatedFiles.push(claudeMdPath);

			// Generate slash command reference
			const slashCommandsContent = this.generateSlashCommandsDoc(agents);
			const slashCommandsPath = Uri.joinPath(claudeDir, 'SLASH_COMMANDS.md');
			await this.fileSystemService.writeFile(slashCommandsPath, new TextEncoder().encode(slashCommandsContent));
			generatedFiles.push(slashCommandsPath);

			this._status = MigrationStatus.Completed;
			this.logService.info('ClaudeMigrationService', 'Migration completed successfully', { generatedFiles: generatedFiles.map(f => f.toString()) });

			return {
				status: MigrationStatus.Completed,
				generatedFiles
			};
		} catch (error) {
			this._status = MigrationStatus.Failed;
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logService.error('ClaudeMigrationService', 'Migration failed', error);

			return {
				status: MigrationStatus.Failed,
				error: errorMessage,
				generatedFiles
			};
		}
	}

	async regenerate(token?: CancellationToken): Promise<MigrationResult> {
		// Clear cached definitions to force refresh
		this._cachedAgentDefinitions = undefined;
		this._status = MigrationStatus.Pending;
		return this.migrate(token);
	}

	async getAgentDefinitions(token?: CancellationToken): Promise<readonly AgentDefinition[]> {
		if (this._cachedAgentDefinitions) {
			return this._cachedAgentDefinitions;
		}

		const definitions: AgentDefinition[] = [...BUILT_IN_AGENTS];

		const workspaceFolder = this.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return definitions;
		}

		// Discover custom agents from .github/agents/ or assets/agents/
		const customAgents = await this.discoverCustomAgents(workspaceFolder.uri, token);
		definitions.push(...customAgents);

		this._cachedAgentDefinitions = definitions;
		return definitions;
	}

	private async discoverCustomAgents(workspaceRoot: Uri, token?: CancellationToken): Promise<AgentDefinition[]> {
		const agents: AgentDefinition[] = [];

		// Check both .github/agents and assets/agents directories
		const agentDirs = [
			Uri.joinPath(workspaceRoot, '.github', 'agents'),
			Uri.joinPath(workspaceRoot, 'assets', 'agents')
		];

		for (const agentDir of agentDirs) {
			try {
				const exists = await this.fileSystemService.exists(agentDir);
				if (!exists) {
					continue;
				}

				const entries = await this.fileSystemService.readDirectory(agentDir);
				for (const [name, type] of entries) {
					if (type === 1 /* FileType.File */ && name.endsWith('.agent.md')) {
						const agentPath = Uri.joinPath(agentDir, name);
						const agent = await this.parseAgentFile(agentPath, name, token);
						if (agent && !this.isBuiltInAgent(agent.name)) {
							agents.push(agent);
						}
					}
				}
			} catch (error) {
				this.logService.warn('ClaudeMigrationService', `Failed to read agent directory: ${agentDir.toString()}`, error);
			}
		}

		return agents;
	}

	private async parseAgentFile(path: Uri, fileName: string, token?: CancellationToken): Promise<AgentDefinition | undefined> {
		try {
			const content = await this.fileSystemService.readFile(path);
			const text = new TextDecoder().decode(content);

			// Extract agent name from filename (e.g., "MyAgent.agent.md" -> "my-agent")
			const baseName = fileName.replace('.agent.md', '');
			const kebabName = this.toKebabCase(baseName);

			// Parse frontmatter and content
			const { frontmatter, body } = this.parseFrontmatter(text);

			const name = frontmatter.name || kebabName;
			const description = frontmatter.description || this.extractFirstParagraph(body) || `Custom agent: ${name}`;
			const instructions = body.trim();

			return {
				name,
				description,
				slashCommand: `/${kebabName}`,
				instructions,
				isBuiltIn: false
			};
		} catch (error) {
			this.logService.warn('ClaudeMigrationService', `Failed to parse agent file: ${path.toString()}`, error);
			return undefined;
		}
	}

	private parseFrontmatter(content: string): { frontmatter: Record<string, string>; body: string } {
		const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
		const match = content.match(frontmatterRegex);

		if (!match) {
			return { frontmatter: {}, body: content };
		}

		const frontmatterText = match[1];
		const body = match[2];
		const frontmatter: Record<string, string> = {};

		for (const line of frontmatterText.split('\n')) {
			const colonIndex = line.indexOf(':');
			if (colonIndex > 0) {
				const key = line.substring(0, colonIndex).trim();
				const value = line.substring(colonIndex + 1).trim().replace(/^['"]|['"]$/g, '');
				frontmatter[key] = value;
			}
		}

		return { frontmatter, body };
	}

	private extractFirstParagraph(text: string): string | undefined {
		const lines = text.split('\n');
		const paragraphLines: string[] = [];

		for (const line of lines) {
			const trimmed = line.trim();
			if (trimmed === '' && paragraphLines.length > 0) {
				break;
			}
			if (trimmed !== '' && !trimmed.startsWith('#')) {
				paragraphLines.push(trimmed);
			}
		}

		return paragraphLines.length > 0 ? paragraphLines.join(' ') : undefined;
	}

	private toKebabCase(str: string): string {
		return str
			.replace(/([a-z])([A-Z])/g, '$1-$2')
			.replace(/[\s_]+/g, '-')
			.toLowerCase();
	}

	private isBuiltInAgent(name: string): boolean {
		return BUILT_IN_AGENTS.some(agent => agent.name === name.toLowerCase());
	}

	private generateClaudeMdContent(agents: readonly AgentDefinition[]): string {
		const builtInAgents = agents.filter(a => a.isBuiltIn);
		const customAgents = agents.filter(a => !a.isBuiltIn);

		const lines: string[] = [
			MIGRATION_MARKER,
			`${MIGRATION_VERSION_PREFIX}${CURRENT_MIGRATION_VERSION} -->`,
			'',
			'# Claude Code Configuration',
			'',
			'This file configures Claude Code for this repository. It is auto-generated from',
			'the `.github/agents/` configuration files.',
			'',
			'## Available Agents',
			'',
			'The following agents are available for use in this repository:',
			'',
			'### Built-in Agents',
			''
		];

		for (const agent of builtInAgents) {
			lines.push(`- **${agent.slashCommand}** - ${agent.description}`);
		}

		if (customAgents.length > 0) {
			lines.push('');
			lines.push('### Custom Agents');
			lines.push('');

			for (const agent of customAgents) {
				lines.push(`- **${agent.slashCommand}** - ${agent.description}`);
			}
		}

		lines.push('');
		lines.push('## Agent Instructions');
		lines.push('');
		lines.push('### General Guidelines');
		lines.push('');
		lines.push('When using agents:');
		lines.push('1. Use the appropriate agent for the task at hand');
		lines.push('2. Provide clear, specific instructions');
		lines.push('3. Review agent output carefully before applying changes');
		lines.push('');

		// Add consolidated instructions from custom agents
		if (customAgents.length > 0) {
			lines.push('### Custom Agent Instructions');
			lines.push('');

			for (const agent of customAgents) {
				lines.push(`#### ${agent.name}`);
				lines.push('');
				// Truncate long instructions
				const truncatedInstructions = agent.instructions.length > 500
					? agent.instructions.substring(0, 500) + '...'
					: agent.instructions;
				lines.push(truncatedInstructions);
				lines.push('');
			}
		}

		lines.push('## Usage');
		lines.push('');
		lines.push('To use an agent, mention it at the start of your message:');
		lines.push('');
		lines.push('```');
		lines.push('/architect Design a new authentication system');
		lines.push('/reviewer Review the changes in the last commit');
		lines.push('/agent Implement the feature described above');
		lines.push('```');
		lines.push('');
		lines.push('## Regeneration');
		lines.push('');
		lines.push('This file is auto-generated. To regenerate:');
		lines.push('1. Run command: `Copilot: Regenerate Claude Configuration`');
		lines.push('2. Or delete this file and it will be recreated on next Claude interaction');
		lines.push('');

		return lines.join('\n');
	}

	private generateSlashCommandsDoc(agents: readonly AgentDefinition[]): string {
		const lines: string[] = [
			MIGRATION_MARKER,
			`${MIGRATION_VERSION_PREFIX}${CURRENT_MIGRATION_VERSION} -->`,
			'',
			'# Slash Commands Reference',
			'',
			'This document lists all available slash commands for agents in this repository.',
			'',
			'| Command | Description | Type |',
			'|---------|-------------|------|'
		];

		for (const agent of agents) {
			const type = agent.isBuiltIn ? 'Built-in' : 'Custom';
			lines.push(`| \`${agent.slashCommand}\` | ${agent.description} | ${type} |`);
		}

		lines.push('');
		lines.push('## Detailed Usage');
		lines.push('');

		for (const agent of agents) {
			lines.push(`### \`${agent.slashCommand}\``);
			lines.push('');
			lines.push(`**Description:** ${agent.description}`);
			lines.push('');
			lines.push(`**Type:** ${agent.isBuiltIn ? 'Built-in' : 'Custom'}`);
			lines.push('');
			lines.push('**Example:**');
			lines.push('```');
			lines.push(`${agent.slashCommand} [your request here]`);
			lines.push('```');
			lines.push('');
		}

		return lines.join('\n');
	}
}

/**
 * Creates an instance of ClaudeMigrationService
 */
export function createClaudeMigrationService(
	instantiationService: IInstantiationService
): IClaudeMigrationService {
	return instantiationService.createInstance(ClaudeMigrationService);
}
